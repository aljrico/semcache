% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrap.R
\name{sc_wrap}
\alias{sc_wrap}
\title{Wrap a Function with Cache}
\usage{
sc_wrap(
  cache,
  fn,
  mode = c("both", "exact", "semantic"),
  embed_fn = NULL,
  key_fn = NULL,
  record_errors = TRUE
)
}
\arguments{
\item{cache}{A \code{semcache} object from \code{\link[=sc_open]{sc_open()}}.}

\item{fn}{The function to wrap.}

\item{mode}{Cache lookup mode: \code{"both"}, \code{"exact"}, or \code{"semantic"}.}

\item{embed_fn}{Optional function that takes the same arguments as \code{fn} and
returns an embedding vector. Used for semantic put/get.}

\item{key_fn}{Optional function that takes \code{...} and returns a request list
suitable for \code{\link[=sc_fingerprint]{sc_fingerprint()}}. If \code{NULL}, the arguments are captured as
a named list.}

\item{record_errors}{If \code{TRUE} (default), errors from \code{fn} are also cached
(wrapped in a \code{simpleError}).}
}
\value{
A wrapped function with the same interface as \code{fn}.
}
\description{
Returns a new function that checks the cache before calling \code{fn}. On a
cache miss the underlying function is called, and the result is stored.
}
\examples{
\donttest{
cache <- sc_open(tempfile("semcache_"), semantic = "off")
my_fn <- function(prompt) paste0("answer:", prompt)
cached_fn <- sc_wrap(cache, my_fn, mode = "exact")
cached_fn("hello")
cached_fn("hello")  # served from cache
}
}
